---
title: "EEPROM Glitch"
permalink: /docs/eeprom-glitch/
excerpt: "Issues when using EEPROMs to produce control signals"
---

EEPROMs are a straightforward and convenient way to produce the system control signals.
Microcode is stored in EEPROMs with the Step Counter (Ring Counter) and Instruction
Register values driving the EEPROM address lines and the EEPROM data outputs providing the
system control signals.  However, there is an important property of EEPROM operation that
causes problems.

## The EEPROM "glitch"

When the address lines on an EEPROM are changed, there is a settling period before the
outputs show the data value at the associated address.  During this time, the outputs are
still being driven (they are not floating), but it is not known if they will be in a high
state or a low state.  For example, if the bytes at address 4 and address 5 both contain a
zero bit for pin D0, the pin could still briefly produce a 1 value when the address is
changed from 4 to 5.  Although this is a normal property of memory chips, it causes issues
because of the way the chips are used in TTL computer builds.  The problem has been
referred to as EEPROM glitching.

Unpredictable signals from the Microcode EEPROM can cause spurious signals to be
generated.  For example, if multiple register read lines are active at once, it will cause
brief bus contention.  If the signals are combined with other logic to generate clocks for
other chips, then spurious clock pulses could be generated.

## Instruction cycle

The [WaveDrom](https://wavedrom.com) timing diagram below shows the first four clock
cycles for an instruction in the SAP-1 and NQSAP computers.  The Ring Counter value
changes on every falling clock edge and the Instruction Register value changes on the
rising edge of microinstruction step 1 (T1).  Both of these events change the address
inputs to the EEPROMs and cause a brief period of uncertainty for all of the control
outputs.  In addition, the SAP-1 also drives address lines with the outputs of the flags
register, so this causes uncertainty on any rising edge that modifies the flags.

![Instruction cycle timing](../../assets/images/timing-instruction-cycle.png "cycle timing showing EEPROM glitch")

For the SAP-1 design, these output glitches are not usually a problem.
Many of the instruction steps in the SAP-1 designs move values from one register to
another.  The SAP-1 uses 74LS173 registers to read and store values from the bus and
74LS245 tranceivers to put values on the bus. For example, the T0 step of every instruction
moves the contents of the Program Counter (PC) to the Memory Address Register (MAR).  
The timing diagram below shows the Program Counter Out (CO) and MAR In (MI) lines.

![Instruction cycle with control clock](../../assets/images/timing-control-clock.png "cycle timing with control clock")

The following steps take place during the first instruction step:
* At marker 1, the Ring Counter is set to zero on the falling edge of CLK
* The Control EEPROM address is set to the T0 instruction cycle
* The CO and MI signals are asserted after briefly being in an unknown state while the EEPROM settles
* The CO signal places the contents of the PC on the bus
* At marker 3, the rising CLK edge, along with the MI signal, causes the PC value on the bus to be loaded into the MAR

The glitching of the MI signal does not cause any problems because the 74LS173 registers
only load new values when the Load Enable signal is asserted and the clock is at a rising edge.  The signals are always in a known state at the rising CLK edge.

## Issues when generating clock signals

Unlike the 74LS173 registers, some chips do not have two independent lines for Load Enable
and CLK.  Instead, a single pin is pulsed and the chip loads when a clock pulse edge is
detected.  Examples in the NQSAP-PCB design are the static RAM, the 74HCT193 counters used
by the Stack Pointer, and the 74HCT74 flip flops used to store the flags. For these chips,
a clock signal is generated by ANDing a control signal with the system clock.  This
produces a pulse whenever the signal is asserted and the CLK is high.  

The timing diagram below shows a control clock pulse being generated in microinstruction
cycle T3.  The control signal is asserted at marker 13 and the clock pulse begins at
marker 15.  


![Instruction cycle with control clock](../../assets/images/timing-control-clock.png "cycle timing with control clock")

Note that the signal uncertaintly at marker 13 does not cause a problem because the clock
signal is still low at that point, so the state of the control signal does not matter.  Similarly, none of the other EEPROM glitching on the falling edge of the clock causes
an issue.

The EEPROM glitch behavior does cause a problem in microinstruction step T1 at marker 7.
This is the point where the Instruction Register is loaded, and that causes the EEPROM
address to change on the positive edge of the system clock.  With the CLK signal high,
any glitch on the control line will produce one or more brief control clock pulses that
could cause their register to idadvertantly load a value from the bus.  

In the SAP-1 design, the flag outputs also drive microcode EEPROM address lines to do
conditional jumps, so the glitch would also be a problem during any microinstruction step
that loads new flag values.

## Mitigating the glitch with analog solutions

Several analog solutions have been proposed to mitigate the EEPROM glitching in TTL computer builds.  One approach is to add low-pass filters to the control lines to eliminate
the high frequency spikes that occur during the EEPROM address switching.

Another solution is to use pull-up or pull-down resistors on the control lines.
Because the lines are not floating during the glitch period, this does not actually
pull the signals to a desired state.  Instead, it just flattens the rise or fall time of
the signal a bit.  If the period of the glitch is short enough, this may cause the
glitch pulse to never cross a logic threshold that would make other hardware act on it.

## NQSAP-PCB design to avoid the glitch

The NQSAP-PCB solves the EEPROM glitch in the digital domain by making changes
to the design of the Conditional Jumps and the Instruction Register.  The conditional
jumps are performed completly in hardware, without the use of separate microcode for
the flag set and flag clear conditions.  Because the flags are not wired to the EEPROM
address lines, changing flag values does not cause any glitches.

The Instruction Register uses a double-buffered design to move the address line changes to
the falling edge of the clock pulse.  The IR is loaded as usual on the positive edge of
the clock in T1.  The outputs of this register are connected to the inputs of a second
register which is loaded on every falling clock pulse.  The outputs of this second
register are used to drive the address lines of the EEPROM.  The result is that the
address lines driven by the IR now change on the falling edge of instruction cycle T1, at
the same time as the address lines driven by the Ring Counter.  With these two design
changes, the outputs of the microcode EEPROMs are always stable when the clock is high, so
they can safely be used with rising clock edges or ANDed with the clock signal.
